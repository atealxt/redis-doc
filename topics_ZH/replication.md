复制
===

Redis复制是一个非常容易配置和使用的主从复制功能，实现了Redis主服务至从服务的精确拷贝。
下面是一些关于Redis复制的重要说明：

* Redis使用异步复制。从Redis 2.8开始，从服务会周期性的报告复制流中已处理的数据数量。

* 主服务可以有多个从服务。

* 从服务可以接受其他从服务连接。除了一个主服务可以连接多个从服务之外，从服务也可以连接其他从服务，像图结构一样。

* Redis复制在主服务端是非阻塞的。在一个或多个从服务执行初始化同步时，主服务可以继续响应请求。

* Redis复制在从服务端也是非阻塞的。从服务在执行初始化同步时可以使用旧版本的数据集继续响应请求，这是默认设置。
或者可以配置Redis从服务在与主服务的连接中断时向客户端的发送一个错误。
但是在初始化同步后，需要删除旧的数据集并装载新的。这一刻从服务会阻塞住外来连接。

* 复制也可以被用来做水平扩展，多个从服务提供只读查询服务（例如，重量的 `SORT` 操作可以放到从服务上进行），或简单的把从服务作为数据冗余。

* 可以使用复制避免主服务端的数据持久化开销：配置主服务的 `redis.conf` ，关闭其保存功能即可（注释掉所有的 "save" 指令），并在从服务上进行数据保存。
使用这种配置时请确保主服务不会自动重启（更多信息请见下面的章节）。

关闭主服务持久化时的复制安全性
---

在使用Redis复制时，强烈推荐开启主服务的持久化。如果无法这么做的话，比如考虑到延迟，实例的配置应该 **避免自动重启** 。

为了更好的理解主服务在关闭复制时自动重启这一危险行为，在下面这个失败的场景中，主从的所有数据都丢失了：

1. 节点A作为主服务并关闭持久化，节点B和C从A复制数据。
2. A节点的服务发生崩溃，通过自动重启系统重启了进程。由于其关闭了持久化，节点的数据都丢失了。
3. 而后节点B和C从A复制数据，将自己的数据集清空。

当配置高可用性的Redis Sentinel，关闭主服务持久化并开启自动重启功能仍然是危险的。
例如主服务的重启足够快Sentinel没能发现错误，上面的失败场景仍然会发生。

当在主服务关闭持久化的场景下使用复制时，如果数据的安全性很重要，应禁用实例的自动重启。

Redis复制是如何工作的
---

如果设置了主从，从服务将会通过连接向主服务发送一个SYNC命令进行同步，不管是第一次进行连接还是重连。

主服务随即开始在后台生成数据镜像文件，同时缓存所有新的涉及修改数据集的命令。
文件生成后，主服务将其传送至从服务。
从服务先将其保存在磁盘上，然后装入内存。
然后主服务将所有缓存命令发送至从服务。
此操作使用Redis协议中的流式命令完成。

可以通过telnet来试验一下。
在Redis主服务正在工作时连接到从服务并发出 `SYNC` 命令进行观察。
将会看到主服务同步过来的一系列命令在telnet会话中依次重新执行。

当主 <-> 从连接由于某些原因失效时，从服务可以自动重连。
即使主服务接收到了多个从服务并发的同步请求，也只会执行一次后台保存。

当主服务与从服务成功重连后，将会重新进行一次完整同步。
从Redis 2.8开始，也可以进行部分重同步。

部分重同步
---

Redis从2.8版本开始，在复制链接宕掉并恢复以后，通常可以继续复制而不再需要进行一次完整同步。

主服务端将复制流储存在内存中，同时主服务与所有从服务遵从 *复制偏移量* 和 *主服务运行ID* 的约定。
当链接宕掉后，从服务会重连接并向主服务请求继续复制。
如果主服务的运行ID仍然与之前的相同，且复制日志中的偏移量仍然有效，复制将会继续进行。
如果任一条件未满足，将执行一次完整重同步（已在2.8预览版中作为默认行为）。
由于主服务链接的运行id没有持久化到磁盘，当从服务重启时需要进行一次完整重同步。

部分重同步这个新功能在Redis内部使用的是 `PSYNC` 命令，而在旧的实现里使用的是 `SYNC` 命令。
注意，Redis 2.8版本的从服务是知道主服务是否支持 `PSYNC` 的，如果不支持将会使用 `SYNC` 替代。

无磁盘依赖复制
---

通常一次完整的重同步需要先创建RDB文件至磁盘，再将它载入从服务的数据集。

对于磁盘性能不高的主服务来说这个操作可能会有很大的压力。
Redis 2.8.18是第一个支持无磁盘依赖复制功能的版本，在此配置下子进程直接将RDB发送至从服务，不会使用磁盘临时保存文件。

此功能尚处于实验性阶段。

配置
---

配置复制非常简单：仅需要在从服务配置文件中加一行：

    slaveof 192.168.1.1 6379

当然你需要将192.168.1.1 6379替换为你的主服务的IP地址（或主机名）和端口。
或者可以调用 `SLAVEOF` 命令让主服务开始与从服务同步。

还有一些参数可以调整主服务复制时执行部分重同步的内存使用。
更多信息请见 `redis.conf` 例子文件的分布式部分。

可以使用配置参数 `repl-diskless-sync` 启用无磁盘依赖复制。
参数 `repl-diskless-sync-delay` 用来控制等待更多从服务加入的延迟传送时间。
更多信息请查阅 `redis.conf` 例子文件的分布式部分。

只读从服务
---

自Redis 2.6开始从服务支持只读模式且默认是开启状态。
此行为由redis.conf文件的 `slave-read-only` 选项控制，并且可以在运行时使用 `CONFIG SET` 开启或禁用。

只读从服务会拒绝所有写操作，这样就不会误将数据写入从服务。
这不代表此功能设计用于将从实例暴露给有不信任客户端存在的因特网或更广泛的网络，因为 `DEBUG` 或 `CONFIG` 等管理员级别的命令仍然是可用的。
但是可以使用 `rename-command` 直接在redis.conf中配置某些命令禁止使用，提高只读实例的安全性。

也许你想知道为什么可以改变只读设置让从实例可写。
这是因为虽然写入的数据会在重同步或从服务重启后被覆盖，仍然可能有一些临时数据需要存放在从服务上。
不过以后这个功能可能会被移除掉。

从服务连接主服务的权限设置
---	

如果主服务通过 `requirepass` 设置了密码，可以很容易的配置从服务在所有同步操作中使用该密码。

在运行的实例中，使用 `redis-cli` 并输入：

    config set masterauth <password>

如欲持久化设置，将此行加到配置文件中：

    masterauth <password>

只在有N个以上可用的复制结点时接受写操作
---

从Redis 2.8开始，可以配置Redis主服务只在有N个以上有效的从服务连接时接受写请求。

然而因为Redis使用的是异步复制，无法确保从服务接收到写操作，所以有可能发生数据丢失。

写操作是这样工作的：

* Redis从服务每秒ping一次主服务，通知复制流执行的情况。
* Redis主服务将会记住每个从服务最后一次ping的时间。
* 用户可以配置从服务的最大延迟秒数。

如果至少有N个从服务的延迟小于M秒，则认为写操作成功。

在CAP理论中可以认为这是一个的宽松版的 "C" ，虽然写操作不能完全保证一致性，但至少数据丢失的时间窗口被限制在了指定秒数内。

如果条件未满足，主服务将会返回一个错误，写操作将不被接受。

共有两个配置参数可在此特性中使用：

* min-slaves-to-write `<number of slaves>`
* min-slaves-max-lag `<number of seconds>`

更多信息请查阅 `redis.conf` 例子文件，此文件在Redis源码项目里。

Redis复制如何处理过期键
---

Redis的过期机制可以限制键的生存时间。
这样的功能依赖于实例计时的能力，而Redis从服务能够正确复制有超时设置的键，甚至用Lua脚本修改过的键。

为了实现此功能，Redis不能依赖于主从服务的时钟同步，这会导致抢占及数据集分散等无法修复的问题，所以Redis主要使用了三种技术实现了超时键的复制：

1. 从服务不做键过期处理，而是交由主服务进行。当主服务的键过期了（或经由LRU淘汰），主服务将向所有从服务发送一个 `DEL` 命令。
2. 然而因为由主服务驱动的超时机制，有时候主服务没能及时发送 `DEL` 命令，从服务内存仍会存在逻辑上已过期的键。
为了解决此问题，从服务 **只针对读操作** 使用自己的逻辑时钟对这种不应存在的键进行报告，而不会破坏数据集的一致性（从主服务来的命令终会到来）。 
这样一来从服务就不会报告逻辑超时的键仍旧存在了。
具体来说，从服务使用了一个HTML片段缓存来记录那些已经过期了却仍然存在的元素。
3. 在执行Lua脚本时不对键做超时处理。
当Lua脚本运行时，概念上主服务的时间被冻结了，所以指定键在整个脚本执行过程时间内要么存在，要么就不存在。 
这样就避免了键在脚本执行过程中超时，脚本在发送到从服务后也能对数据集起到相同的效果。

由预想的那样，一旦发生了故障转移，从服务变为了主服务，它可以独立开始键淘汰，不需要旧主服务的帮忙。
