此文章提供了关于Redis持久化技术的说明，推荐所有Redis用户阅读。
关于对Redis持久化及提供持久化保证的更深层次描述，可以阅读 [Redis持久化揭秘](http://antirez.com/post/redis-persistence-demystified.html).

Redis持久化
===

Redis提供了好几种持久化的选择：

* RDB持久化以指定的频率按照时间点保存数据集快照。
* AOF持久化对服务接收到的每个写操作进行记录，并在服务重启动时回放，重新创建原来的数据集。命令使用Redis协议的格式，以只可追加方式进行记录。当日志文件很大时，Redis可以在后台操作重写。
* 如果愿意的话可以完全禁用持久化，让数据只存在于服务运行的时候。
* 可以在一个实例上联合使用AOF与RDB。注意在这种情况下，Redis重启后将使用AOF文件重建数据集，因为它更能保证数据的完整性。

最需要了解的是RDB和AOF在持久化上的不同权衡。让我们从RDB开始：

RDB的优点
---

* RDB以时间点作为依据紧凑的将Redis数据保存至单个文件。
RDB文件非常适合用于备份。
例如每个小时将过去24个小时的RDB文件进行一次归档，并每天对过去30天的数据保存一次RDB快照。
发生灾难时可以很容易的恢复任一版本的数据集。
* RDB很适合用于灾备，作为紧凑的单文件可以远程传输至数据中心，或Amazon S3 （或许需要加密）。
* RDB最大化了Redis的性能，Redis主进程唯一要做的就是给从服务创建一个任务进行持久化。
主实例不会进行磁盘I/O之类的操作。
* 在有较大数据集的时候，相对于AOF来说RDB重启非常快。

RDB的缺点
---

* 由于Redis可能会停止工作（比如服务器断电），RDB不适合用在不能有数据丢失的场景。
RDB可以设置 *保存点* （例如至少经过五分钟或对数据集进行了100次写，保存点可以设置多个）。
通常RDB快照都会设置五分钟或更久的保存点，当Redis因各种原因异常停止工作后，自上一次快照后的数据将会丢失。
* RDB需要 fork() 以使用子进程进行磁盘持久化。
如果数据集很大 fork() 可能会很久，并且可能会阻塞住Redis服务若干毫秒甚至一秒，CPU也会上升。
虽然AOF也会 fork() 但时间取决于写日志的多少，而且不会中断服务。

AOF的优点
---

* 使用了AOF的Redis可靠性大大增强：可以设置多种不同的同步策略：不同步、每秒同步、每次请求后同步。
默认每秒同步的策略的写操作性能已然很好了（同步使用后台线程进行，主线程会在没有同步进行的时候接收并执行写操作），但有可能丢失最多一秒钟的数据。
* AOF日志是只可追加的，所以不会有查询，在服务器掉电时也不会损坏。
即使因为一些情况（磁盘空间不足或其他原因）日志写操作进行一半时中断了，使用工具 redis-check-aof 也可以轻松修复。
* 在AOF文件过大时Redis可以在后台自动对其进行重写。
重写过程是安全的，首先使用表示当前数据集的最小操作集合生成一个新文件，此时当Redis继续向旧文件添加数据时同时向新文件中添加，当新文件就绪以后Redis会将AOF指向新文件。
* AOF的日志包含了所有的操作，格式非常简单并易于理解。
甚至可以轻松的手动导出一个AOF文件。
例如，即使错误的使用了 FLUSHALL 命令清空了数据，如果这时还没有执行日志重写，是可以通过停止服务器、删除最后一条命令并重启Redis来恢复数据的。

AOF的缺点
---

* AOF文件通常要比有着同样数据的RDB文件要大。
* AOF可能会比RDB慢，这取决于同步策略。
一般来说设置 *每秒* 同步的AOF性能还是很不错的，而禁用同步的话将会和RDB一样快，即使在负载很高的情况下。
尽管如此在高写操作负载时RDB更能保证最大延迟时间。
* 在此之前我们经历了少量由特殊命令引起的缺陷（例如产生阻塞的命令BRPOPLPUSH）会导致AOF产生无法准确还原数据集的问题。
这样的缺陷非常少见，并且我们已经使用了测试套件进行了自动测试，随机创建复杂的数据集并重新装载以确保其正确。这种缺陷在RDB中几乎不可能发生。
更进一步来讲：Redis AOF是在增量更新已有状态，就像MySQL和MongoDB那样。而RDB快照是一次又一次的进行全量创建，概念上讲更强壮。
然而 -
  1) 值得关注的是，每次Redis进行AOF重写都会从现有数据集中全量重建。比起只是向AOF文件添加数据（或使用旧的AOF而不是内存中的数据进行重写）来说，这有效的阻止了缺陷的发展。
  2) 我们至今还没有接到任何关于用户在实际使用AOF中发生损坏的报告。

那么，该使用哪个呢？
---

一般来说如果想要达到像PostgreSQL那样的数据安全级别的话应该同时使用两种持久化方法。

如果能够忍受几分钟的数据丢失的话，可以只使用RDB。

有很多人只使用AOF，我们却不推荐这样，因为定期创建RDB快照可以很好的进行数据库备份，有更快的重启速度，并且可以避开AOF引擎尚未发现的bug。

注意：鉴于这些个原因，我们倾向于在以后将AOF和RDB合并成一个持久化模型（这是个长期计划）。

下面详细的介绍一下两种持久化模型。

<a name="snapshotting"></a>
创建快照
---

默认Redis会向磁盘创建数据集快照，一个叫做 `dump.rdb` 的二进制文件。
可以配置Redis每N秒在至少有M个数据修改的情况下保存数据，或者手动调用命令 `SAVE` 或 `BGSAVE` 。

例如，这个配置会让Redis自动的每隔60秒在至少有1000个键变化时创建数据集快照：

    save 60 1000

这种策略称之为 _创建快照_ 。

### 它是如何工作的

当Redis需要创建快照时，就会建立一个分支进程：

* Redis [forks](http://linux.die.net/man/2/fork)。 
这样就有了一个子进程和一个父进程。

* 子进程开始将数据集写入至一个临时RDB文件。

* 当子进程完成写入后，使用新的RDB文件替换原来的。

此种写时复制的技术实现了Redis RDB的高效。

<a name="append-only-file"></a>
只可追加文件
---

快照方式的可靠性不是最好的。
如果运行Redis的计算机关机、掉电或意外 `kill -9` 杀掉进程的话，最后写入Redis的数据将会丢失。
对于某些应用程序来说这可能不算什么，但对于那些需要完整可靠性的场合来讲就不可行了。

作为代替，Redis的 _只可追加文件_ 方式提供了完整的可靠性策略。
从1.1版本开始可以使用。

可以在配置文件中打开AOF：

    appendonly yes

这样一来，Redis会把接收到的任何修改数据集的命令（如 `SET` ）添加到AOF中。
重启Redis时会重放AOF的命令重建数据集。

### 日志重写

可以预见到的是，随着写操作的增加AOF会变得越来越大。
例如，对一个计数器自增一百次，最终在数据集中只会有一个键对应一个值。但是在AOF中则会有100个，其中99个在重建数据集时都不需要。

所以Redis有了一个有意思的功能：可以在后台重建AOF而且不会妨碍服务运行。
当触发一个 `BGREWRITEAOF` Redis就会计算重建当前数据集所需要的最少命令序列并进行写入。
Redis 2.2需要人工调用 `BGREWRITEAOF` ，Redis 2.4则可以建立自动重写日志的触发器（更多信息请见2.4的配置例子）。

### 只可追加文件的持久性

Redis可以配置数据 [`fsync`](http://linux.die.net/man/2/fsync) 至磁盘的频率。
一共有三种选择：

* AOF每接收到一个新命令时执行一次 `fsync` 。很安全但非常非常慢。

* 每秒执行一次 `fsync` 。足够快（在2.4版中和创建快照一样快），但在发生灾难时会丢失近一秒钟的数据。

* 不执行 `fsync` ，将数据全权交由操作系统处理。是最快但不安全的方式。

推荐（也是默认）的策略是每秒执行一次 `fsync` 。
这兼顾了快速与安全。
 `每次都同步` 的策略在实践中非常慢（即使在Redis 2.0中性能得到了提升） – `fsync` 已经无法再快了。

### 如果AOF文件损坏了怎么办？

服务器在写AOF文件时发生崩溃有可能导致文件损坏无法再次读取（但不会发生数据不一致）。
发生此错误时可以使用以下步骤进行修复：

* 备份AOF文件。

* 使用Redis的 `redis-check-aof` 工具修复原始文件：

      $ redis-check-aof --fix <文件名>

* 可以使用 `diff -u` 检查两个文件的区别。

* 使用修复后的文件重启服务。

### 日志重写是如何工作的

日志重写和建立快照一样使用写时复制：

* Redis [建立分支任务](http://linux.die.net/man/2/fork)，即一个子进程一个父进程。

* 子进程开始向临时文件写入新的AOF。

* 父进程将所有新的修改保存在内存缓冲区（并同时写入至旧的只可追加文件，这样当重写发生错误时也是安全的）。

* 子进程完成重写后，父进程会获得一个信号量，并向文件末尾写入内存缓冲区的数据。

* 好消息！Redis现在可以自动完成新旧文件的重命名，并自动继续向新文件中添加数据。

### 如果我正在使用dump.rdb快照，如何切换至AOF？

Redis 2.0和Redis 2.2 的处理过程是不一样的，Redis 2.2更简单甚至不需要重启。

**Redis >= 2.2**

* 备份最新的dump.rdb文件。
* 把备份文件保存至安全的地方。
* 执行下面两条命令：
* redis-cli config set appendonly yes
* redis-cli config set save ""
* 检查切换前后数据库的键的数量是否相同。
* 确认写操作是否能够正确的添加到只可追加文件中。

第一个CONFIG命令用来开启只可追加文件。
这时 **Redis将会阻塞** 以生成初始化快照，然后开放只可追加文件的写入，自此之后的写操作将会被添加至文件中。 

 第二个CONFIG命令用来关闭快照方式的持久化。
这步是可选的，也可以两种持久化都开启。

**注意：** 记得编辑 redis.conf 开启AOF，否则当重启服务时修改的配置将会丢失，服务将重新使用旧的配置。

**Redis 2.0**

* 备份最新的dump.rdb文件。
* 把备份文件保存至安全的地方。
* 停止向数据库的所有写操作！
* 执行 redis-cli bgrewriteaof ，创建只可追加文件。
* 当生成完AOF快照后停止服务器。
* 修改 redis.conf 启用只可追加文件持久化。
* 重启服务。
* 检查切换前后数据库的键的数量是否相同。
* 确认写操作是否能够正确的添加到只可追加文件中。

AOF与RDB的相互影响
---

Redis >= 2.4 确保在生成RDB快照时不会执行AOF重写和在执行AOF重写时不会执行BGSAVE。这防止了Redis在后台同时进行两种高磁盘I/O处理。

当正在生成快照时，如果用户使用BGREWRITEAOF显式请求日志重写操作，服务会返回OK状态码并说明操作已安排就绪，重写会在快照生成完毕后执行。

当AOF和RDB都启用时，Redis重启后会使用AOF文件恢复数据集，因为AOF更能保证数据的完整性。

备份Redis数据
---

开始此章节前，请先阅读这句话： **备份数据库** 。
在磁盘损坏、云实例消失等状况下，没有备份意味着有巨大的数据丢失风险，就像把数据丢入/dev/null一样。

Redis对数据备份非常友好，可以在数据库运行时拷贝RDB文件：生成后的RDB是不会修改的，在生成时它使用临时文件名，并且只在新的快照生成完毕后使用rename(2)自动进行重命名。

这意味着在服务运行时拷贝RDB文件是完全安全的。推荐的做法是：

* 在服务器上创建一个cron job，每小时在指定文件夹内创建RDB文件快照，并每天拷贝到不同的文件夹下。
* 每次cron脚本运行时，调用 `find` 命令确保删除过旧的快照：比如只保存最近48个以小时为单位的快照，和一至两个月内的以天为单位的快照。记得以数据及日期命名快照文件名。
* 确保每天最少一次将RDB快照保存至 *数据中心外* 或 至少是运行Redis的 *物理机以外* 的服务器。

灾难恢复
---

Redis环境的灾难恢复基本上等同于备份，加上将备份的文件传至多个不同的外部数据中心。
这样即使运行并产生快照的Redis数据中心发生灾难性事件，也能保证数据的安全性。

由于很多Redis的用户处于起步阶段没有大量的资金，便宜一些的灾难恢复技术是非常有吸引力的。

* 用Amazon S3以及其他类似的服务作为灾难恢复存储是个好办法，每天或每小时将加密后的RDB文件传送至S3保存。 
可以使用 `gpg -c` （对称加密方式）加密数据，并确保将密码保存到多个安全的地方（比如拷贝给组织中最重要的人）。 
推荐使用多个存储服务以提高数据安全性。
* 使用SCP（SSH的一部分）远程传输快照。
这很简单并且安全：找一个离你所在地很远的地方申请一个小型VPS，安装ssh，并生成一个不包含密码的ssh客户端键，然后将它加入到你VPS的authorized_keys文件中。
这样就可以自动传送备份文件了。
为了更好的效果，至少使用两家不同运营商的VPS。

记住，如果操作不当这也很容易导致失败。

一定要确认传输完毕的文件大小（至少应和多份拷贝中的一份的大小相同），并尽可能比对SHA1摘要。

一个独立的告警系统也是必要的，用来监测备份文件的传输是否工作正常。

