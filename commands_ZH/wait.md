阻塞当前客户端，直到之前所有的写操作成功发送到至少指定个数的从服务并收到应答。
如果达到指定的毫秒则发生超时，即使没有完成指定数量的从服务连接，命令也将会返回。

不论是达到了指定从服务数量还是发生了超时，命令 `WAIT` **都将返回** 在执行之前确认了的所有写操作的从服务数量。

一点说明：

1. 当 `WAIT` 返回时，返回值代表当前客户端的所有以前的写操作被成功接收的从服务数量。
2. 在 `MULTI` 事务中，执行此命令将不会发生阻塞，而是尽快返回应答了之前写操作的从服务数量。
3. 超时设为0意味着一直阻塞。
4. 虽然在 `WAIT` 失败和成功时都会返回确认的从服务数量，客户端仍然应该检查返回值是否大于等于复制中的设定值。

一致性与WAIT
---

注意 `WAIT` 并没有让Redis变成强一致性的存储：因为同步复制只是复制状态机的一部分，不是全部。但是在Sentinel或Redis集群失败转移中， `WAIT` 确实提高了数据的安全性。

比如一个写操作发送到了一个或多个从服务，如果主服务失败，通常（但不保证）通过失败转移是可以将接收到写操作的从服务进行提升的：Sentinel和Redis集群会尽最大可能从可用的从服务中挑选出最合适的。

然而这只是尽最大可能，写操作仍然可能丢失在多从服务的同步复制过程中。

实现细节
---

自发明从服务的部分重同步（PSYNC功能）以来，Redis从服务就可以异步地与主服务通信，传递复制流中已完成部分的偏移量。
这个功能用在了好几个地方：

1. 探测超时的从服务。
2. 在断开连接后执行部分重同步。
3. 实现 `WAIT` 。

在 `WAIT` 的实现中，Redis为每个客户端记录了执行写操作后的复制流偏移量。
当调用 `WAIT` 时Redis会检查是否有指定数量的从服务应答了该偏移量或更大的偏移量。

@return

@integer-reply: 命令返回当前连接上下文中确认了所有执行了的写操作的从服务数量。

@examples

```
> SET foo bar
OK
> WAIT 1 0
(integer) 1
> WAIT 2 1000
(integer) 1
```

在上面的例子中，第一次调用 `WAIT` 没有使用超时，查询写操作至少到达了1个从服务的从服务数量。命令返回成功。
第二次调用设置了超时，查询至少到达2个。由于只有一个从服务可用，一秒钟后 `WAIT` 解除阻塞并返回1，即到达的从服务数量。
