`BLPOP` 是一个阻塞的列表弹出命令。
它是阻塞版本的 `LPOP` ，当给定的列表中没有元素可弹出时将它会阻塞住连接。
从给定键的顺序开始检查每个列表，当列表非空时从队首弹出第一个元素并结束命令。

## 非阻塞行为

当执行 `BLPOP` 命令时，如果键序列中至少有一个键的值为非空列表，将会弹出第一个非空列表的队首元素，并且将此键一同返回给调用者。

键以给定的顺序进行验证。
假设键 `list1` 不存在而 `list2` 和 `list3` 持有非空列表。
考虑以下命令：

```
BLPOP list1 list2 list3 0
```

`BLPOP` 担保返回 `list2` 的列表里的一个元素（按顺序从 `list1` ， `list2` 和 `list3` 检查出的第一个非空列表的元素）

## 阻塞行为

如果键序列中没有有效的键，直到另一个客户端对其中一个键执行了 `LPUSH` 或 `RPUSH` 命令为止 `BLPOP` 将阻塞住连接。

一旦有新数据出现在某一个列表中，客户端将停止阻塞并收到该数据所在列表的键及弹出的值。

当 `BLPOP` 阻塞了客户端且指定一个非零的超时设置，如果在超时时间过期前没有使用其中至少一个键进行push操作的话客户端将会停止阻塞并收到一个 `nil` 数组。

**超时参数被解释为一个代表最大阻塞秒数的整数值**。超时设为零可以进行无期限阻塞。

## 优先处理哪个键？哪个客户端？哪个元素？关于优先级排序的细节。

* 如果客户端尝试因多个键阻塞，而至少有一个键含有元素，则返回的键/值对是从左到右数第一个含有元素的键。这样客户端将不会阻塞。例如 `BLPOP key1 key2 key3 key4 0` ，假设 `key2` 和 `key4` 都不为空，则总是会从 `key2` 中返回一个元素。
* 如果多个客户端因相同的键而阻塞，等待时间较长的客户端将先获得服务（第一个因该键而阻塞的客户端）。一旦客户端取消了阻塞它就不再持有优先权，在下一次调用 `BLPOP` 阻塞时将会排在其它因相同键而阻塞的客户端的后面，其他的客户端会优先获得服务（从阻塞排队的第一个变成最后一个）。
* 当一个客户端因多个键而阻塞的同时，有多个键的元素在同一时刻变得可用（因为事务、或者在Lua脚本中向多个列表添加元素），客户端将会解除阻塞并使用第一个接受了推操作的键（假设有足够多的元素提供给客户端，同时可能有其他的客户端也在等待此键）。基本上来说Redis在执行每个命令后会运行一个列表的键来接收数据，并且至少有一个客户端会被阻塞。列表以新元素的到达时间进行排序，从第一个获得了数据的键到最后一个。对于每个键来说，只要键中有元素，Redis就会让所有客户端以FIFO的形式为该键进行排队。当键为空或不再有客户端等待时，下一个在之前的命令/事务/脚本中接收到新数据的键将会被处理，以此类推。

## 当多个元素被添加到一个列表时 `!BLPOP` 的行为。

以下具有相同概念的命令可以使一个列表接收多个元素：

* 可变参数的添加操作如 `LPUSH mylist a b c` 。
* 在向一个列表添加多个元素的 `MULTI` 块执行 `EXEC` 操作之后。
* 在Redis 2.6或更新的版本中执行Lua脚本。

当多个元素被添加到一个有多个客户端阻塞等待的列表中时，Redis 2.4与Redis 2.6或更新版本的行为是不一样的。

在Redis 2.6版本执行添加多个元素的命令时， *只有在命令执行后*阻塞的客户端才能得到服务。请考虑以下命令。

    客户端A:   BLPOP foo 0
    客户端B:   LPUSH foo a b c

如果以上条件发生在Redis 2.6服务器或以上版本， 客户端 **A** 将获得 `c` 元素，因为在 `LPUSH` 命令执行后列表包含 `c,b,a` ，所以从左侧开始获取一个元素即返回 `c` 。

而在Redis 2.4中却是另一种情况：客户端在添加操作的*同时*得到服务，所以当 `LPUSH foo a b c` 开始添加第一个元素至列表的时候，它就会被发送至客户端 **A** ，客户端将会接收到 `a` （第一个添加的元素）。

Redis 2.4的这种行为在复制或持久化数据至AOF文件时会产生很多问题，所以通常简单的做法是升级Redis至2.6版本来预防这些问题的发生。

注意由于相同的原因一个Lua脚本或 `MULTI/EXEC` 块可能会向一个列表添加完元素后再 **删除这个列表** 。这样一来阻塞的客户端将根本得不到服务，只要在一个命令、事务或脚本执行完后没有数据出现在列表中客户端就会一直被阻塞。

## 处于 `!MULTI` / `!EXEC` 事务中的 `!BLPOP`

`BLPOP` 可以用于管道通信（批量发送命令与接收应答），但这几乎仅在它作为管道的最后一个命令时才有用。

在 `MULTI` / `EXEC` 块中使用 `BLPOP` 不会有太大的好处。为了以原子方式执行块命令，这会要求阻塞整个服务器端，反之又不允许其他客户端执行push操作。所以当 `BLPOP` 处于 `MULTI` / `EXEC` 中并且列表为空时将会返回 `nil` 数组，这与到达超时时间的效果是一样的。

如果你喜欢科幻小说，想象一下在 `MULTI` / `EXEC` 块内时间正以无限的速度流淌着。。。

@return

@array-reply: 具体为：

* 当没有元素可被弹出且超时时间过期时返回 `nil` 数组。
* 返回由两个元素组成的数组。第一个元素是弹出值所在列表的键，第二个元素是弹出值。

@examples

```
redis> DEL list1 list2
(integer) 0
redis> RPUSH list1 a b c
(integer) 3
redis> BLPOP list1 list2 0
1) "list1"
2) "a"
```

## 可靠队列

当 `BLPOP` 向客户端返回元素时，也会从列表中删除此元素。这意味着元素只存在于客户端的环境中：如果在处理返回值时客户端崩溃了，元素将永久性丢失。

这在一些应用程序比如可靠性消息系统中可能会造成问题。如果需要的话请考虑使用 `BRPOPLPUSH` 命令，它是 `BLPOP` 的变种，在把元素返回至客户端前会把它存到目标列表中。

## 模式: 事件通知

使用阻塞列表操作可以实现别样的阻塞方式。
例如在一些程序中你需要进行阻塞等待，直到有元素进入Redis集合，这就可以使用非轮询的方式实现。
这需要阻塞版的 `SPOP` （系统未实现），但使用阻塞列表操作我们可以很容易的实现这个任务。

消费者的处理：

```
LOOP forever
    WHILE SPOP(key) returns elements
        ... process elements ...
    END
    BRPOP helper_key
END
```

而在生产者端我们使用简单的：

```
MULTI
SADD key element
LPUSH helper_key x
EXEC
```
