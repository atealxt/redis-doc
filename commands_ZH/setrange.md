重写存储在 _键_ 的部分字符串，从指定的偏移量开始，长度为 _值_ 。
如果偏移量大于当前存储在 _键_ 的字符串的长度，字符串会以零字节进行填补去适应 _偏移量_ 。
不存在的键被认为是空字符串，所以本命令将确定它持有一个足够大的字符串以可以在 _偏移量_ 处设置 _值_ 。

注意可设置的最大偏移量为 2^29 -1 (536870911)，即Redis字符串的512兆字节限制。
如果需要额外的长度，可以使用多个键。

**警告**：当设置最后一个比特并且 _键_ 还没有持有字符串值、或持有较小的字符串值时，Redis需要申请全部的中间内存，这将有可能阻塞住服务器一定的时间。
在2010 MacBook Pro中，设定字节数为536870911（512MB分配空间）需要大约300ms，设定字节数为134217728（128MB分配空间）需要大约80ms，设定字节数为33554432（32MB分配空间）设置需要大约30ms，设定字节数为8388608（8MB分配空间）需要大约8ms。
注意一旦第一次分配完成后，随后对相同的 _键_ 调用 `SETRANGE` 将不会再进行额外的内存申请。

## 模式

有了 `SETRANGE` 和类似的 `GETRANGE` 命令，使用Redis字符串就可以像使用线性数组一样以O(1)进行随机访问。
在很多真实世界的用例中，这是非常快速与高效的存储方式。

@return

@integer-reply: 使用命令修改后的字符串长度。

@examples

基本用法：

```cli
SET key1 "Hello World"
SETRANGE key1 6 "Redis"
GET key1
```

补零的例子：

```cli
SETRANGE key2 6 "Redis"
GET key2
```
