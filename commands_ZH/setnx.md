如果 `键` 不存在，设置 `键` 持有字符串 `值` 。
这种情况下，它等同于 `SET` 。
如果 `键` 已持有值，将不作任何操作。
`SETNX` 是缩写版的 "如果 **不存在** 则 **SET** "。

@return

@integer-reply, 具体为：

* `1` 如果键被设置
* `0` 如果键没有被设置

@examples

```cli
SETNX mykey "Hello"
SETNX mykey "World"
GET mykey
```

## 设计模式：使用 `!SETNX` 进行锁定。

**请注意：**

1. 以下模式已不推荐使用，  [Redlock算法](http://redis.io/topics/distlock) 的实现比此模式只复杂一点，但具有更好的容错性保障。
2. 在此保留旧模式的原因是，已经有一些实现引用了此页面。而且这也是一个阐述如何使用Redis命令实现编程原语的好例子。
3. 不管怎样即使假设在单例的锁原语环境下， 从2.6.12开始也可以创建简单得多的锁原语，效果和此处的相同。关于使用 `SET` 请求锁使用简单Lua脚本释放锁的模式，记录在了命令文档 `SET` 中。
也就是说，由于历史原因 `SETNX` 可以被用作锁原语。例如，为了获得键 `foo` 的锁，客户端可以尝试：

```
SETNX lock.foo <current Unix time + lock timeout + 1>
```

如果 `SETNX` 返回 `1` 则客户端获得了锁，键 `lock.foo` 设定的Unix时间即为锁失效的时间。
客户端将在之后使用 `DEL lock.foo` 来释放锁。

如果 `SETNX` 返回 `0` 则键已被其他客户端锁住。
如果锁是非阻塞的我们可以返回至调用者，或循环重试以获得锁直至成功或超时之类的处理。

### 处理死锁

上述锁定算法存在一个问题：如果客户端失败、崩溃或其他情况不能释放锁会怎样？
由于锁的键包含一个UNIX时间戳，可以检测到这种情况。
如果时间戳等于当前的Unix时间，锁将不再有效。

发生这种情况时我们不能仅对key调用 `DEL` 来移除锁并再发出一次 `SETNX` ，因为这时已经存在竞争条件，多个客户端检测到了锁超时并正尝试释放它。

* C1和C2读取 `lock.foo` 检查时间戳，因为它们执行 `SETNX` 后都收到了 `0` ，而这时锁仍被已崩溃了的C3持有。
* C1发出 `DEL lock.foo`
* C1发出 `SETNX lock.foo` 并成功
* C2发出 `DEL lock.foo`
* C2发出 `SETNX lock.foo` 并成功
* **错误**：由于竞争条件的存在，C1和C2都取得了锁。

幸运的是，可以使用下面的算法来避免这个问题。
让我们来看看使用良好算法的正常客户端C4是如何做的：

*   C4发出 `SETNX lock.foo` 请求获得锁

*   崩溃了的客户端C3仍旧持有它，所以Redis返回 `0` 至C4。

*   C4发出 `GET lock.foo` 检查锁是否过期。
    如果没有，休眠一段时间后继续检查。

*   相反，如果锁过期了， `lock.foo` 上的Unix时间大于当前Unix时间，C4尝试执行：

    ```
    GETSET lock.foo <current Unix timestamp + lock timeout + 1>
    ```

*   由于 `GETSET` 的语义，C4可以检查存储在 `键` 的旧值是否仍旧是一个过期时间戳。
    如果是，则获得锁。

*   如果另一个客户端例如C5，比C4更快的用 `GETSET` 操作获得了锁，C4的 `GETSET` 操作将返回一个没有过期的时间戳。
    这样C4将简单的从第一步重新开始。
    注意即使C4将键的值向后设定了几秒钟也不会造成什么问题。

为了让此锁定算法更健壮，持有锁的客户端应该在对键使用 `DEL` 释放锁前确认锁没有过期。因为客户端的故障可能非常复杂，不仅是崩溃，也可能由一些命令导致长时间阻塞，在很长时间以后再尝试执行 `DEL` （此时锁已被另一个客户端所获得）。
