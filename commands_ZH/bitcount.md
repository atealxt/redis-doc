统计字符串中设置比特位的数量（比特位设置总数）。

默认检查字符串包含的所有字节。
可以通过传入额外参数 _起始_ 和 _结束_ 来指定计数操作区间。

像 `GETRANGE` 命令一样起始和结束可以为负数，以指定从字符串末尾开始索引，-1表示最后一个字节，-2表示倒数第二个，以此类推。

不存在的键作为空字符串进行处理，命令返回零。

@return

@integer-reply

设置为1的比特位的数量。

@examples

```cli
SET mykey "foobar"
BITCOUNT mykey
BITCOUNT mykey 0 0
BITCOUNT mykey 1 1
```

## 模式：使用位图进行实时统计

位图是一种非常节省空间的表示各种信息的结构。
举个例子，一个Web应用程序需要从用户访问历史中统计出哪些用户适合进行beta特性测试。

使用 `SETBIT` 命令可以轻松实现，使用一个小的逐位整数对每天的访问进行记录。
例如应用程序发布的第一天为第0位，下一天为第1位，以此类推。

每次当用户浏览页面时，应用程序可以使用 `SETBIT` 命令对该用户访问网站记录中当天的比特位置进行设置。

随后可以很容易的调用 `BITCOUNT` 命令访问位图，得到用户访问网站的天数。

一个类似的模式，使用用户ID来代替天作为比特位：[使用Redis位图结构进行快速而易用的实时统计][hbgc212fermurb]。

[hbgc212fermurb]: http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps

## 性能方面的考虑

对于上面日期计数的例子，即使记录10年的数据应用程序也只会对每个用户占用 `365*10` 个比特，仅仅456字节。
而使用 `BITCOUNT` 取得总数也能像其他Redis的O(1)命令一样快，如 `GET` 或 `INCR` 。

当位图十分巨大时，有两个选择可供代替：

* 将键进行拆分使用多个位图进行存储。
  使用一个很小的Redis Lua脚本就可以高效而原子的实现它。
* 使用 `BITCOUNT` 的_起始_ 和 _结束_ 可选参数来增量访问位图，在客户端累计结果，并可选的对结果进行缓存。
