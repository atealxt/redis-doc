给 `键` 设置一个超时时间。
当超时时间过期后，键将自动被删除。
Redis常使用术语 _volatile_ 来描述设置了超时的键。

当使用 `DEL` 命令移除键、或使用 `SET` 或 `GETSET` 重写键的值的时候，超时设置将被移除。
超时设置只可能被那些删除或重写键内容的命令清除，包括 `DEL` 、 `SET` 、 `GETSET` 以及所有 `*STORE` 命令。
这意味着从概念上讲所有 _修改_ 键的值，而不是将值替换为一个新值的操作都会保留超时设置。
举例来讲，使用 `INCR` 递增值、使用 `LPUSH` 向列表内推入新值、或使用 `HSET` 修改哈希所在字段的值，都是保留超时设置的操作。

超时设置也可以被清除，使用 `PERSIST` 命令将键转换回持久化的键。

如果使用 `RENAME` 重命名键，相关的生存时间会转给新的键。

如果使用 `RENAME` 重命名了键，例如一个已存在的键 `Key_A` 被诸如 `RENAME Key_B Key_A` 的命令重写，无论 `Key_A` 的源是否有超时设置，新键 `Key_A` 都会继承 `Key_B` 的所有特性。

注意使用非正数的数字调用 `EXPIRE`/`PEXPIRE` 或过去时间调用 `EXPIREAT`/`PEXPIREAT` ，会导致键被[删除][del] ，而不是过期（键触发的[事件][ntf]是 `del` ，不是 `expired` ）。 

[del]: /commands/del
[ntf]: /topics/notifications

## 刷新有效期

可以对已经设置了有效期的键调用 `EXPIRE` 。
这样键的生存时间会被 _更新_ 为新的值。
对此有很多有用的程序，例如后面所讲的 _导航会话_ 模式。

## Redis 2.1.3版本之前的差异

在Redis 2.1.3版本以前，修改具有超时设置的键的值会删掉整个键。
由于复制条件的限制，造成了当时的这种行为，现已解决。

@return

@integer-reply, 具体为:

* 如果超时设置成功返回 `1` 。
* 如果键不存在或无法设置超时时间返回 `0` 。

@examples

```cli
SET mykey "Hello"
EXPIRE mykey 10
TTL mykey
SET mykey "Hello World"
TTL mykey
```

## 模式: 导航会话

假设有一个web service，对用户 _最近_ 访问的前N个页面感兴趣，每个新的页面访问记录不会比前一个存储超过60秒的时间。
从概念上讲这些页面浏览记录就像是用户的 _导航会话_ ，包含着他/她正在寻找什么样商品的有趣信息，这样就可以推荐相关商品了。
在Redis里可以轻松的使用如下策略实现此模式：用户每次访问页面时执行如下命令：

```
MULTI
RPUSH pagewviews.user:<userid> http://.....
EXPIRE pagewviews.user:<userid> 60
EXEC
```

如果用户闲置超过60秒，键将被删除，只有少于60秒间隔时间的页面连续查看才会被记录。

此模式可以容易的修改为使用 `INCR` 制作计数器，来替代使用 `RPUSH` 保存具体数据列表。

# 附录：Redis的有效期

## 具有有效期的键

通常Redis创建键并不会为其设置生存时间。
键会一直有效，除非被用户明确的移除，例如使用 `DEL` 命令。

 `EXPIRE` 系列命令以键消耗一些额外内存为代价，给键设置一个有效期。
当键设置了有效期，Redis可以确保其在度过有效期后被删除掉。

键的生存时间可以通过使用 `EXPIRE` 或 `PERSIST` 命令（或其他的相关命令）进行更新或者彻底移除。

## 有效期的精确度

在Redis 2.4有效期并不是非常准确，可能会存在零到一秒的误差。

从Redis 2.6起有效期的误差降至0到1毫秒。

## 有效期与持久化

键的有效期信息以绝对Unix时间戳的形式进行存储（Redis 2.6版本及以上使用毫秒为单位）。
这意味着即使停掉Redis实例，有效期时间仍旧会继续计算。

为了能使有效期很好的工作，计算机时间必须是稳定的。
如果你在两台具有很大时延的计算机之间进行RDB文件迁移，可能会发生有趣的事（例如加载时所有的键已全部超时）。

即使运行实例的计算机经常进行时钟矫正，举个例子，当你给一个键设置了1000秒的生存时间，并在之后让计算机时钟延后2000秒，键会立即失效，而不是在1000秒之后。

## Redis是如何设置键到期的

Redis有2种方法设置键到期：被动方式，和主动方式。

当有客户端访问键的时候，如果键已超时则为主动过期。

当然这并不能满足那些从未被访问过的过期键。
无论如何这些键都应该被设为过期，所以Redis会周期性随机抽取键进行过期验证。
所有抽到的过期键将从键存储区中删除。

Redis每秒会进行十次如下操作：

1. 随机性从键存储区拿出20个键进行超时检测。
2. 删除所有找到的过期键。
3. 如果过期键超过了25%，从第一步重新开始。

这是一个概念上再简单不过的算法，以抽取的样本代表整个键存储区为基本假设，并重复进行检测直至过期键的比率小于25%

这意味着在任何时刻，占用内存的已过期键的最大数量是每秒写操作最大数量的四分之一。

## 在复制链接及AOF文件中处理超时

为了获得正确的行为而又不失一致性，当键到期时AOF文件和所有的从服务器都将接收一个 `DEL` 操作。
这样一来，超时处理在主服务器实例进行集中管理，不会发生一致性错误。

虽然连接主服务器的从服务器不会独自进行键到期处理（而是会等待主服务器发来的 `DEL` ），但是仍然会在数据集中完全保留超时设置信息，
这样当从服务器被提升为主服务器时可以自主的进行键到期处理，从而充当主服务器。
