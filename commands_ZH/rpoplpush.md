原子性的移除并返回存储在 `源` 列表的最后一个元素（末尾元素），并把它作为第一个元素（头元素）推入存储于 `目标` 的列表。

例如：考虑 `源` 持有列表 `a,b,c` ， `目标` 持有列表 `x,y,z` 。
执行 `RPOPLPUSH` 的结果为 `源` 持有 `a,b` 并且 `目标` 持有 `c,x,y,z` 。

如果 `源` 不存在，将返回 `nil` 值且不执行任何操作。
如果 `源` 和 `目标` 相同，操作相当于从列表中删除末尾元素并把它添加为首元素，所以可以视其为一个循环列表命令。

@return

@bulk-string-reply: 弹出并推入的元素。

@examples

```cli
RPUSH mylist "one"
RPUSH mylist "two"
RPUSH mylist "three"
RPOPLPUSH mylist myotherlist
LRANGE mylist 0 -1
LRANGE myotherlist 0 -1
```

## 模式：可靠队列

Redis经常被用来作为消息服务器执行后台作业或其他类型的消息任务。
一个简单的队列常常是由生产者向一个列表推入值，并等待消费者使用 `RPOP` （使用轮询）或更佳的 `BRPOP` 阻塞操作。

然而在这种环境中队列并不 _可靠_ ，消息有可能丢失，例如发生网络错误或消费端服务恰好在接收到消息正在处理时崩溃。

`RPOPLPUSH` （或阻塞版本 `BRPOPLPUSH` ）提供了避免此问题的办法：消费者在接受信息的同时将其放入一个 _执行_ 列表。
在消息处理完成后再使用 `LREM` 从 _执行_ 列表中删除。

可以使用一个额外的客户端监控 _执行_ 列表，需要的话将存在时间过长的元素作为超时元素重新放入队列中。

## 模式：循环列表

使用相同的键作为 `RPOPLPUSH` 的源和目标，客户端可以用O(N)的复杂度依次访问有N个元素的列表的所有元素，而不必使用 `LRANGE` 操作将整个列表从服务器端传给客户端。

此模式甚至可以在下面两种限制条件下正常工作：

* 有多个客户端在循环访问列表：它们会取得不同的元素，直到所有元素被访问到，然后重新开始。
* 另外有客户端在不停的向列表尾部添加新元素。

这样系统能很容易的实现让N个工作线程尽可能快的处理一组元素。
例如一个监控系统必须在最短时间内检查一组网站是可用的，可以通过并行工作线程实现。

值得注意的是此工作线程的实现方式具有非常好的扩展性及可靠性，因为即使消息丢失了元素仍然会在队列里，并且会在下次迭代时继续处理。
