此命令的行为是：

* 停止所有客户端。
* 如果至少配置了一个 **保存点** ，执行一次阻塞保存。
* 如果开启了AOF，刷新只可追加文件。
* 关闭服务。

如果开启了持久化，此命令会在关闭前确保Redis没有丢失任何数据。
这并不能保证如果客户端简单使用 `SAVE` 之后 `QUIT` 的这种情况，因为别的客户端可以在这两个命令中间修改DB的数据。

注意：一个没有配置持久化的Redis实例（没有配置AOF，也没有直接执行 "save" ）在 `SHUTDOWN` 时将不会生成RDB文件，也就是说你通常并不希望只作为缓存的Redis实例在停止服务时发生阻塞。

## SAVE和NOSAVE修饰符

可以指定一个可选修饰符来改变命令的行为。
具体为：

* **SHUTDOWN SAVE** 将触发一次DB保存操作，即使没有配置保存点。
* **SHUTDOWN NOSAVE** 将阻止进行DB保存操作，即使配置了一个或多个保存点。
  （可以简单的认为这是另一个版本的 **中止** 命令，仅仅用来停止服务）。

## SHUTDOWN NOSAVE 失败的情况

当使用 **NOSAVE** 选项时，RDB文件不会保存到磁盘上。
但如果启用了只可追加文件，事情将会变得复杂。
通常，如果有AOF子进程正在执行AOF重写，Redis将会杀掉子进程并退出。
但是有两种情况下这么做不安全， **SHUTDOWN NOSAVE** 命令将会被拒绝并返回错误：

* 用户仅仅启用了AOF，服务器触发了第一次AOF重写首次建立AOF文件。
这种时候，停止将会导致丢失所有数据集：一旦重启，服务器将面临启用了AOF但没有AOF文件的状态。
* 启用了AOF的从服务对主服务进行重连，执行完整重同步重新生成AOF文件，触发初始化AOF文件进程。 
在这种情况下，不完成AOF重写将会是危险的，从主服务接收的最新数据集将会丢失，新的主服务甚至都有可能是另外一个实例（如果使用了 **SLAVEOF** 重新配置从服务）。
所以需要完成AOF重写，以便能在服务器停止前正确保存内存中的数据集。

但是有时候我们确实需要尽快停掉Redis实例，不考虑内容。
正确的做法是使用一组命令， 先执行 **CONFIG appendonly no** ，随即 **SHUTDOWN NOSAVE** 。
第一个命令会确保关闭AOF，并停掉任何工作中的AOF重写子进程。 
关闭了AOF，再执行第二个命令就不会有任何问题了。

@return

在错误时返回 @simple-string-reply 。
在成功时不返回任何信息，服务停止，连接关闭。
