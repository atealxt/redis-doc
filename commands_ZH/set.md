给 `键` 设置字符串 `值` 。
如果 `键` 已持有值，将被重写，不论之前的类型是什么。
所有关于此键的生存时间设置在 `SET` 操作执行成功后将被丢弃。

## 选项

从Redis 2.6.12开始 `SET` 支持一系列可修改其行为的选项：

* `EX` *seconds* -- 设置指定的超时时间，以秒为单位。
* `PX` *milliseconds* -- 设置指定的超时时间，以毫秒为单位。
* `NX` -- 当且仅当键不存在时进行设置。
* `XX` -- 当且仅当键已存在时进行设置。

注意：自此 `SET` 可以替换 `SETNX` 、 `SETEX` 、 `PSETEX` ，在未来的Redis版本中这三个命令可能会变为不推荐使用，直至删除。

@return

@simple-string-reply: 如果 `SET` 正确执行则返回 `OK` 。
@nil-reply: 如果因用户指定的 `NX` 或 `XX` 选项条件未满足 `SET` 操作没有执行，则返回Null Bulk应答。

@examples

```cli
SET mykey "Hello"
GET mykey
```

## 模式

**注意：** 以下模式已不推荐使用，  [Redlock算法](http://redis.io/topics/distlock) 的实现比此模式只复杂一点，但具有更好的容错性保障。

命令 `SET 资源名 字符串 NX EX 锁能持有的最长时间` 是一个简单的在Redis中实现锁功能的方法。

如果以上命令返回 `OK` 客户端就可以获得锁（而如果命令返回Nil，就在一定时间后进行重试），并可以仅使用 `DEL` 来删除。

在超时时间到达后锁将会被自动释放。

可以使用以下方法让系统释放锁的处理变得更加健壮：

* 不使用固定的字符串，而使用一个不可推测的长随机串，称之为令牌。
* 不使用 `DEL` 释放锁，而运行一个脚本，只在键的值匹配时进行移除。

这可以避免客户端在超时后进行锁释放，却删除了由另一个客户端为获得锁而创建的键。

解锁脚本看起来会是如下这样：

    if redis.call("get",KEYS[1]) == ARGV[1]
    then
        return redis.call("del",KEYS[1])
    else
        return 0
    end

脚本应该使用 `EVAL ...脚本... 1 资源名 令牌值` 的方式进行调用。
